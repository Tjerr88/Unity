<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Unity 2025 — Go-time Edition</title>
<style>
  :root{color-scheme:dark}
  *{box-sizing:border-box}
  body{margin:0;background:#0b1220;color:#e6eaf2;font:16px/1.6 system-ui,Arial}
  .app{max-width:980px;margin:0 auto;padding:16px 12px 84px}
  h1{margin:0 0 .6rem;font-size:28px}
  h2{margin:0;font-size:18px}
  .btn{background:#2b63ff;border:0;color:#fff;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:800;transition:transform .06s ease}
  .btn.ghost{background:#1a2a4a}
  .btn.inline{padding:8px 10px;border-radius:10px}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row.stack>*.btn{flex:1}
  .card{background:#101a30;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;margin:10px 0}
  .session{white-space:pre-wrap;background:#0e182c;border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:16px;line-height:1.7;font-family:ui-monospace,monospace;font-size:clamp(13px,1.9vw,16px)}
  .pill{display:inline-block;background:#182446;border-radius:999px;padding:5px 12px;font-size:12px;margin:3px 3px 0 0}
  details{border:1px solid rgba(255,255,255,.08);border-radius:12px}
  summary{list-style:none;cursor:pointer;padding:12px;font-weight:800;background:#0f1a34;border-radius:12px}
  summary::-webkit-details-marker{display:none}
  details[open]>summary{border-bottom:1px solid rgba(255,255,255,.08);border-bottom-left-radius:0;border-bottom-right-radius:0}
  .panel{padding:12px}
  label{font-size:12px;opacity:.88;display:block;margin:8px 0 4px}
  select,input[type="text"]{width:100%;background:#0d1830;border:1px solid rgba(255,255,255,.18);color:#e6eaf2;padding:10px;border-radius:10px}
  .grid{display:grid;gap:10px}
  .cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media (max-width:760px){
    .cols-2{grid-template-columns:1fr}
    .row.stack{display:grid;grid-template-columns:1fr;gap:8px}
    .btn{padding:14px 16px;border-radius:14px}
  }
  .muted{opacity:.75;font-size:12px}
  .toast{position:fixed;right:12px;bottom:12px;background:#0f1a34;border:1px solid rgba(255,255,255,.15);padding:10px 12px;border-radius:12px;font-size:13px;display:none}
  .badge{display:inline-block;font-weight:800;font-size:12px;padding:3px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.25);margin-left:6px;background:#0f1a34}
  /* Tabs */
  .tabs{display:flex;gap:8px;margin:10px 0 6px}
  .tab-btn{background:#0f1a34;border:1px solid rgba(255,255,255,.15);color:#e6eaf2;padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer}
  .tab-btn.active{background:#2b63ff;border-color:#2b63ff}
  .tab-pane{display:none}
  .tab-pane.active{display:block}
  /* Counters & lines */
  .counter{display:inline-flex;align-items:center;gap:8px;margin-left:12px;flex:0 0 auto}
  .counter .cbtn{background:#0f1a34;border:1px solid rgba(255,255,255,.2);color:#e6eaf2;border-radius:10px;padding:4px 10px;font-weight:800;cursor:pointer}
  .counter .cval{min-width:64px;text-align:center;font-weight:900}
  .session .line{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:nowrap}
  .session .line .txt{flex:1;min-width:0;white-space:normal}
  .row-inline{display:flex;gap:8px;align-items:center}
  .row-inline input[type="text"]{flex:1}
  .chk{display:inline-flex;gap:6px;align-items:center;font-size:12px;opacity:.9}
</style>
</head>
<body>
<div class="app">
  <h1>Unity 2025</h1>

  <div class="tabs" role="tablist" aria-label="Navigatie">
    <button class="tab-btn active" data-tab="plan" aria-selected="true">Planner</button>
    <button class="tab-btn" data-tab="custom" aria-selected="false">Eigen oefeningen</button>
  </div>

  <!-- Planner -->
  <div id="tab-plan" class="tab-pane active">
    <div class="row stack" style="margin:8px 0 12px">
      <button id="btnPrevTop" class="btn ghost" aria-label="Vorige sessie">◀ Vorige</button>
      <button id="btnNextTop" class="btn" aria-label="Volgende sessie">Volgende ▶</button>
      <button id="btnCompleteTop" class="btn inline" title="Markeer deze sessie als voltooid">Complete ✔</button>
      <button id="btnNewBlock" class="btn inline" title="Nieuw blok (zet alles opnieuw)">Nieuw blok</button>
    </div>

    <div class="card">
      <h2>Huidige sessie</h2>
      <div id="session" class="session" aria-live="polite">Nog geen blok. Klik op “Nieuw blok”.</div>
    </div>

    <details id="accSettings">
      <summary>Instellingen</summary>
      <div class="panel">
        <div class="grid cols-2">
          <div>
            <label>Blokvolume (Unity)</label>
            <select id="selVol">
              <option>180</option><option>240</option><option selected>300</option><option>400</option><option>500</option>
            </select>
          </div>
          <div>
            <label>Seed (optioneel)</label>
            <input id="inpSeed" placeholder="bv. 12345">
          </div>
          <div>
            <label>KB-bias (alleen mains; op basis van week-split)</label>
            <select id="selBias">
              <option value="on" selected>Aan (▲/▼)</option>
              <option value="off">Uit</option>
            </select>
          </div>
          <div>
            <label>Plan Strong overlay (1 grind-patroon)</label>
            <select id="selPS">
              <option value="">— Uit —</option>
              <option>Push</option><option>Pull</option><option>Squat</option><option>Hinge</option>
            </select>
          </div>
          <div>
            <label>PS Volume (indien PS aan)</label>
            <select id="selPSVol" disabled>
              <option>180</option><option selected>240</option><option>300</option>
            </select>
          </div>
          <div>
            <label>PS-modus</label>
            <label class="row" style="gap:10px">
              <input type="checkbox" id="chkPSAdvanced" disabled>
              <span>Advanced: High + Super Heavy</span>
            </label>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div id="kpi"></div>
          <div id="orders" class="muted" style="margin-top:6px"></div>
          <div class="muted" style="margin-top:6px">
            Weekpercentages: Deload 15% • Maintenance 22% • Development 28% • Stress 35%.<br>
            Splits per partitie: 3 → [15,35,50]% • 4 → [15,22,28,35]% • 5 → [10,15,20,25,30]%.<br>
            Bias (alleen mains): min%=Heavy ▲, max%=Light ▼. Light-bias main: cap-boost tot 10 per ronde (geen PS).<br>
            Anti-Rotation main: Snatch (default), maar override via eigen oefeningen is toegestaan.
          </div>
        </div>

        <div class="row stack" style="margin-top:8px">
          <button id="btnRebuild" class="btn">Instellingen toepassen</button>
          <button id="btnReset" class="btn ghost">Reset voortgang</button>
          <button id="btnResetCounters" class="btn ghost" title="Wis set-tellers van deze sessie">Reset tellers</button>
        </div>
      </div>
    </details>
  </div>

  <!-- Custom -->
  <div id="tab-custom" class="tab-pane">
    <div class="card">
      <h2>Eigen oefeningen</h2>
      <p class="muted">Per patroon: vul <b>1 (Main)</b> en 2–4 (accessoires) in. Zet <b>Ballistic (x2)</b> voor swings/snatches e.d. en <b>Unilateral (+/+)</b> voor uni-oefeningen (weergave x+x). Leeg = Unity-standaard.</p>
      <div id="customForm" class="grid cols-2" style="margin-top:8px"></div>
      <div class="row stack" style="margin-top:8px">
        <button id="btnSaveCustom" class="btn">Opslaan</button>
        <button id="btnClearCustom" class="btn ghost">Leegmaken</button>
        <span class="muted">Na opslaan: de Planner wordt direct herbouwd.</span>
      </div>
    </div>
  </div>
</div>

<div id="toast" class="toast" aria-live="polite"></div>

<script>
(function(){
  const LS_KEY='unity2025_state';
  const COUNTERS_KEY='unity2025_counters';
  const CUSTOM_KEY='unity2025_custom_matrix_v5';
  const PATTERNS=['Push','Pull','Squat','Lunge','Hinge','Rotation','Anti-Rotation','Loaded Carry'];
  const WEEK_TYPES=['Deload','Maintenance','Development','Stress'];
  const WEEK_PCT={Deload:.15,Maintenance:.22,Development:.28,Stress:.35};
  const SPLITS={3:[0.15,0.35,0.50],4:[0.15,0.22,0.28,0.35],5:[0.10,0.15,0.20,0.25,0.30]};
  const DEFAULT_BALLISTICS=new Set(['Snatch','One-arm Swing','Two-arm Swing','High Pull','Double Clean']);

  // Default Unity-matrix (Advanced leidend)
  const MATRIX_ADV={
    'Push':{main:'Military Press',acc:['Push Press','Half-kneeling Press','Floor Press']},
    'Pull':{main:'Double Clean',acc:['Pull-up / Chin-up','Double Bent-over Row','High Pull']},
    'Squat':{main:'Double Front Squat',acc:['Goblet Squat','Bulgarian Split Squat','Step-up']},
    'Lunge':{main:'Tactical Lunge',acc:['Double Reverse Lunge','Athletic Lunge','Side Lunge']},
    'Hinge':{main:'Two-arm Swing',acc:['Single-leg Glute Bridge','Double Deadlift','Double Snatch']},
    'Rotation':{main:'Turkish Get Up',acc:['Windmill','Half-kneeling Windmill','Bent Press']},
    'Anti-Rotation':{main:'Snatch',acc:['One-arm Swing','Single-leg Deadlift','Renegade Row']},
    'Loaded Carry':{main:'Suitcase Carry',acc:['Front Rack Carry','Overhead Carry','Bear Crawl']}
  };

  // ===== Helpers =====
  const $=s=>document.querySelector(s);
  const toast=(m)=>{const t=$('#toast');t.textContent=m;t.style.display='block';setTimeout(()=>t.style.display='none',1500);};
  const esc=s=>String(s).replace(/[&<>"']/g,c=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  const clean=s=>String(s).replace(/\s+/g,' ').trim();
  function sanitizeName(s){const x=String(s||'').trim(); if(!x) return ''; if(x==='on'||x==='off') return ''; return x;}
  function makeRNG(seed){let h=2166136261>>>0;if(seed){for(let i=0;i<seed.length;i++){h^=seed.charCodeAt(i);h=Math.imul(h,16777619);}}else{h=(Date.now()>>>0);}return function(){h+=0x6D2B79F5;let t=h;t=Math.imul(t^t>>>15,t|1);t^=t+Math.imul(t^t>>>7,t|61);return ((t^t>>>14)>>>0)/4294967296;}}
  let rnd=makeRNG('');
  function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(rnd()*(i+1));[a[i],a[j]]=[a[j],a[i]]}return a;}
  function roundsCap(v){switch(+v){case 180:return{rounds:3,cap:3};case 240:return{rounds:3,cap:4};case 300:return{rounds:3,cap:5};case 400:return{rounds:4,cap:5};case 500:return{rounds:5,cap:5};default:return{rounds:3,cap:5};}}
  function apportion2(total,weights){const w=weights.slice();const W=w.reduce((a,b)=>a+b,0);if(W<=0)return Array(w.length).fill(0);const raw=w.map(v=>(v*total)/W);const base=raw.map(x=>Math.floor(x));let rem=total-base.reduce((a,b)=>a+b,0);const order=raw.map((x,i)=>({i,frac:x-Math.floor(x)})).sort((a,b)=>b.frac-a.frac);for(let k=0;k<order.length&&rem>0;k++){base[order[k].i]+=1;rem--;}return base;}
  function biasFromPct(weekType,pct){const parts=(weekType==='Deload')?3:((weekType==='Stress')?5:4);const base=SPLITS[parts];const mn=Math.min(...base),mx=Math.max(...base);const eq=(a,b)=>Math.abs(a-b)<1e-9; if(eq(pct,mn))return'Heavy'; if(eq(pct,mx))return'Light'; return'Medium';}
function biasBadge(b){
  return b==='Heavy' ? ' <span class="badge">▲ +1</span>'
       : b==='Light' ? ' <span class="badge">▼ −1</span>'
       : '';
}
// --- Rounds utility: rond een waarde af naar een veelvoud van #rounds ---
function toRounds(x, rounds){
  if (!Number.isFinite(x) || x <= 0) return rounds;
  const k = Math.round(x / rounds);   // dichtstbijzijnde veelvoud
  return Math.max(rounds, k * rounds);
}
// Neem het grootste veelvoud van #rounds dat ≤ total is
function takeRoundsLE(total, rounds){
  if (!Number.isFinite(total) || total <= 0) return 0;
  const k = Math.floor(total / rounds);
  return Math.max(0, k * rounds);
}

  function pickDays(count){const d=[0,1,2,3,4];shuffle(d);return d.slice(0,count).sort((a,b)=>a-b);}

  // LocalStorage JSON helpers
  function loadJSON(k,def){try{const v=localStorage.getItem(k);return v?JSON.parse(v):def}catch(e){return def}}
  function saveJSON(k,o){try{localStorage.setItem(k,JSON.stringify(o))}catch(e){}}

  // Counters
  let counters=loadJSON(COUNTERS_KEY,{}); function countersSave(){saveJSON(COUNTERS_KEY,counters);}
  function dayKey(){if(!state.plan||!state.cursor)return'nokey';const{w,d}=state.cursor;return`${state.blockIdx||0}_${w}_${d}`;}
  function getCount(exKey){const k=dayKey();return(counters[k]&&counters[k][exKey])|0;}
  function setCount(exKey,val,max){const k=dayKey();counters[k]=counters[k]||{};counters[k][exKey]=Math.max(0,Math.min(max,val|0));countersSave();}
  function resetDayCounters(){const k=dayKey();if(counters[k]){delete counters[k];countersSave();}}
  function mkCounterHTML(exKey,max){const cur=getCount(exKey);const safe=exKey.replace(/&/g,'&amp;').replace(/</g,'&lt;');return`<span class="counter" data-ex="${safe}" data-max="${max}"><button class="cbtn" data-dec>−</button><span class="cval">${cur}/${max}</span><button class="cbtn" data-inc>+</button></span>`}

  // Custom matrix (met ballistic/unilateral)
  let customMatrix=loadJSON(CUSTOM_KEY,{})||{};
  function inferBallistic(name){const nm=clean(name);return DEFAULT_BALLISTICS.has(nm)||/(swing|snatch|high pull|double clean)/i.test(nm)}
  function inferUnilateral(name){const n=clean(name).toLowerCase();return /(one-arm|single-leg|pull-up|chin-up|lunge|windmill|bent press|renegade row|military press|push press|snatch)/i.test(n)}
  function seedFromUnity(){const out={};for(const p of PATTERNS){const m=MATRIX_ADV[p];const items=[];items[0]={name:m.main,ballistic:inferBallistic(m.main),unilateral:inferUnilateral(m.main)};for(let i=0;i<3;i++){const nm=m.acc[i]||'';items[i+1]={name:nm,ballistic:inferBallistic(nm),unilateral:inferUnilateral(nm)};}out[p]={enabled:true,items};}return out;}
  function sanitizeCustom(){
    if(!customMatrix||!Object.keys(customMatrix).length){customMatrix=seedFromUnity();}
    for(const p of PATTERNS){
      if(!customMatrix[p]) customMatrix[p]={enabled:true,items:[{},{},{},{}]};
      const it=customMatrix[p].items=customMatrix[p].items||[{},{},{},{}];
      for(let i=0;i<4;i++){
        it[i]=it[i]||{};
        it[i].name=sanitizeName(it[i].name||'');
        if(!it[i].name){
          const seed=seedFromUnity()[p].items[i];
          it[i].name=seed.name; it[i].ballistic=seed.ballistic; it[i].unilateral=seed.unilateral;
        }else{
          if(typeof it[i].ballistic!=='boolean') it[i].ballistic=inferBallistic(it[i].name);
          if(typeof it[i].unilateral!=='boolean') it[i].unilateral=inferUnilateral(it[i].name);
        }
      }
    }
    saveJSON(CUSTOM_KEY,customMatrix);
  }
  function effectiveMatrix(){
    sanitizeCustom();
    const out={}; for(const p of PATTERNS){
      const it=customMatrix[p].items;
      out[p]={main:it[0].name,acc:[it[1].name,it[2].name,it[3].name].filter(Boolean)};
    }
    return out;
  }
  function isBallisticName(nm){const name=clean(nm);for(const p of PATTERNS){const conf=customMatrix[p];if(!conf||!conf.items)continue;for(const it of conf.items){if(clean(it.name)===name) return !!it.ballistic;}}return DEFAULT_BALLISTICS.has(name);}
  function isUnilateralName(nm){const name=clean(nm);for(const p of PATTERNS){const conf=customMatrix[p];if(!conf||!conf.items)continue;for(const it of conf.items){if(clean(it.name)===name) return !!it.unilateral;}}return inferUnilateral(name);}

  // State
  let state=loadJSON(LS_KEY,null)||{};
  function save(){saveJSON(LS_KEY,state);}
function doneKeyFor(w,d){
  return `${state.blockIdx||0}_${w}_${d}`;
}
function markDone(w,d){
  state.completed = state.completed || {};
  state.completed[ doneKeyFor(w,d) ] = true;
  save();
}
function isDone(w,d){
  return !!(state.completed && state.completed[ doneKeyFor(w,d) ]);
}
// Accessoire-rotatie-cursor per patroon (alleen voor multi-accessoire momenten)
function getAccCursor(pattern){
  state.accCursor = state.accCursor || {};
  return state.accCursor[pattern] | 0;
}
function setAccCursor(pattern, val){
  state.accCursor = state.accCursor || {};
  state.accCursor[pattern] = val | 0;
  save();
}


  // Splits & plan
  function buildWeekSplitsWithPcts(blockVol,weekType){
    const parts=(weekType==='Deload')?3:(weekType==='Stress'?5:4);
    const base=SPLITS[parts].slice();
    const {rounds}=roundsCap(blockVol);
    const weekTotal=Math.round(blockVol*(WEEK_PCT[weekType]||0));
    let sess=base.map(p=>Math.max(rounds,Math.round((weekTotal*p)/rounds)*rounds));
    let diff=weekTotal-sess.reduce((a,b)=>a+b,0),idx=sess.length-1;
    while(Math.abs(diff)>=rounds){
      if(diff>0){sess[idx]+=rounds;diff-=rounds;}
      else if(sess[idx]-rounds>=rounds){sess[idx]-=rounds;diff+=rounds;}
      else{if(idx>0){idx--;continue;}break;}
    }
    const o=sess.map((_,i)=>i);shuffle(o);return o.map(i=>({vol:sess[i],pct:base[i]}));
  }
  function pickDays(count){const d=[0,1,2,3,4];shuffle(d);return d.slice(0,count).sort((a,b)=>a-b);}
  function buildPlan(cfg){
    const matrix=effectiveMatrix();
    rnd=makeRNG(cfg.seed||'');
    const lastEnds=state.lastEnds||{};
    const weekOrders={};
    for(const pat of Object.keys(matrix)){
      const order=['Deload','Maintenance','Development','Stress']; shuffle(order);
      if(lastEnds[pat]&&order[0]===lastEnds[pat]){[order[0],order[1]]=[order[1],order[0]];}
      weekOrders[pat]=order;
    }
    const weeks=Array.from({length:4},()=>({days:Array.from({length:5},()=>({entries:[],ps:null}))}));
    for(const [pat,def] of Object.entries(matrix)){
      for(let w=0;w<4;w++){
        const wt=weekOrders[pat][w];
        const items=buildWeekSplitsWithPcts(cfg.volume,wt);
        const dayIdxs=pickDays(items.length);
        for(let i=0;i<items.length;i++){
          const d=dayIdxs[i];
          const {vol,pct}=items[i];
          weeks[w].days[d].entries.push({
            pattern:pat, main:def.main, acc:def.acc.slice(),
            weekType:wt, volume:vol, pct:pct, bias:biasFromPct(wt,pct)
          });
        }
      }
    }
    // Plan Strong overlay
    if(cfg.psPattern){
      const psPat=cfg.psPattern;
      const psBlock=+cfg.psVolume||240;
      const fixed=['Deload','Development','Maintenance','Stress'];
      for(let w=0;w<4;w++){
        const wt=fixed[w];
        const weekVol=Math.round(psBlock*(WEEK_PCT[wt]||0));
        for(let dd=0;dd<5;dd++){
          weeks[w].days[dd].entries = weeks[w].days[dd].entries.filter(en=>en.pattern!==psPat);
        }
        const dayIdxs=pickDays(3);
        let weights=[50,35,15], labels=['Medium','High','Low'], shOnHigh=false;
        if(cfg.psAdvanced){weights=[30,55,15]; shOnHigh=true;}
        const sessVols=apportion2(weekVol,weights);
        const psMain=(matrix[psPat]?.main)||psPat;
        for(let i=0;i<3;i++){
          const d=dayIdxs[i];
          weeks[w].days[d].ps = weeks[w].days[d].ps || {};
          weeks[w].days[d].ps[psPat] = {weekType:wt,reps:sessVols[i],mainName:psMain,level:labels[i],sh:(labels[i]==='High'&&shOnHigh),mode:cfg.psAdvanced?'advanced':'basic'};
        }
      }
    }
    return {weeks, rc:roundsCap(cfg.volume), weekOrders, set:'advanced'};
  }

  // Doordraaien per weektype
  function patternSessionIndex(weekObj, currentDayIdx, patternName){
    let idx=0,total=0;
    for(let d=0; d<weekObj.days.length; d++){
      const has = (weekObj.days[d].entries||[]).some(e=>e.pattern===patternName);
      if(has){ total++; if(d<=currentDayIdx) idx++; }
    }
    return {idx:Math.max(1,idx), total};
  }
function pickAccessoryOrder(weekType, pct, accList, pattern){
  const has = i => i>=0 && i<accList.length;
  const P = x => Math.abs(pct - x) < 1e-9; // veilige float-vergelijking

  if (weekType === 'Deload') return []; // geen accessoires

  if (weekType === 'Maintenance') {
    // 28% -> A1, 35% -> A2
    if (P(0.28)) return has(0) ? [0] : []; // A1
    if (P(0.35)) return has(1) ? [1] : []; // A2
    return [];
  }

  if (weekType === 'Development') {
    // 24% (~0.28 label) -> A1, 33% (~0.35) -> A3
    if (P(0.28)) return has(0) ? [0] : []; // A1
    if (P(0.35)) return has(2) ? [2] : []; // A3
    return [];
  }

  if (weekType === 'Stress') {
    // 15% -> A1, 20% -> A2, 25% -> A3, 30% -> A3 + A1
    if (P(0.15)) return has(0) ? [0] : [];        // A1
    if (P(0.20)) return has(1) ? [1] : [];        // A2
    if (P(0.25)) return has(2) ? [2] : [];        // A3
    if (P(0.30)) {
      const arr = [];
      if (has(2)) arr.push(2); // A3
      if (has(0)) arr.push(0); // A1
      return arr;
    }
    return [];
  }

  return [];
}


  // Render
  function renderSession(){
    const out=$('#session'); if(!state.plan){out.textContent='Nog geen blok. Klik op “Nieuw blok”.';return;}
    const {w,d}=state.cursor; const week=state.plan.weeks[w]; const day=week.days[d]; const rc=state.plan.rc;

    // Opener: Get Up
// Opener: Get Up (toon bias-badge; Light = 2+2, anders 1+1)
let openerHTML=''; 
const rot=day.entries.find(e=>e.pattern==='Rotation');
if(rot){
  const sets=rc.rounds;
  const cost=rc.cap*sets;
  const isLight = (state.cfg.bias==='on' && (rot.bias||'Medium')==='Light');
  const badge  = (state.cfg.bias==='on') ? biasBadge(rot.bias||'Medium') : '';
const repStr = `${sets} × (${isLight ? '2+2' : '1+1'}) Turkish Get Up${badge}`;
// ❌ verwijder esc() zodat HTML-badge niet wordt geëscaped
openerHTML = `<div class="line"><div class="txt">${repStr}</div>${mkCounterHTML('Opener — Turkish Get Up',sets)}</div>`;
  rot.volume = Math.max(0,(rot.volume|0)-cost);
}

    const entries=shuffle(day.entries.slice().filter(e=>e.pattern!=='Loaded Carry'));
    const lines=[];

    // PS inject
    if(day.ps){
      const rounds=rc.rounds; const roundsWeights=Array(rounds).fill(1);
      for(const [pat,info] of Object.entries(day.ps)){
        const T=Math.max(0,info.reps|0); let buckets,labels;
        if(info.mode==='advanced'||info.sh){buckets=apportion2(T,[45,30,20,5]);labels=['L','M','H','SH'];}
        else{buckets=apportion2(T,[50,35,15]);labels=['L','M','H'];}
        const perRound=buckets.map(v=>apportion2(v,roundsWeights)); const roundLabels=[];
        for(let r=0;r<rounds;r++){const parts=[];for(const lab of labels){const idx=labels.indexOf(lab);if(idx>=0&&perRound[idx][r]>0)parts.push(`${lab}${perRound[idx][r]}`);}roundLabels.push(parts.length?parts.join('/'):'—');}
        const detail=roundLabels.map((s,i)=>`R${i+1}:${s}`).join(' • ');
        lines.push({name:`PS — ${info.mainName}`,repText:`${rounds} rounds`,label:` — ${info.level}${info.sh?' (H+SH)':''} — ${detail}`});
      }
    }

    // Unity circuit — doordraaien
    for(const e of entries){
      const order=(e.pattern==='Rotation') ? [...(e.acc||[])].filter(Boolean)
                                           : [e.main,...(e.acc||[])].filter(Boolean);
      const {idx:sessIdx}=patternSessionIndex(week,d,e.pattern);
const accList=(e.pattern==='Rotation')?order:order.slice(1);
const accPick=pickAccessoryOrder(e.weekType, e.pct, accList, e.pattern);

// Multi-accessoire rotatie: ...
let accOrder = accPick.slice();
if (accOrder.length > 1) {
  const cur = getAccCursor(e.pattern) % accOrder.length;
  accOrder = accOrder.slice(cur).concat(accOrder.slice(0, cur));
}

let remaining=e.volume;

      // Main
      if(e.pattern!=='Rotation' && order.length>0){
        const nm=order[0];
const isLightBoost = (state.cfg.bias==='on' && e.bias==='Light' && !day.ps);
// cap per ronde: Light -> 10, anders standaard cap
const targetCap = isLightBoost ? 10 : rc.cap;
  // verdeel in veelvouden van #rounds, en cap per ronde respecteren
  const maxMainThis = targetCap * rc.rounds;                // max wat main mag pakken vandaag
  const assign       = Math.min(maxMainThis, takeRoundsLE(remaining, rc.rounds));
  let perRound       = Math.floor(assign / rc.rounds);
  perRound           = Math.max(0, Math.min(targetCap, perRound));

  if (perRound > 0) {
    const isBall = isBallisticName(nm);
    const isUni  = isUnilateralName(nm);
    const shown  = perRound * (isBall ? 2 : 1);  // x2 is alleen UI, niet in toewijzing
    const repTxt = isUni ? `${shown}+${shown}` : `${shown}`;
    const label  = (state.cfg.bias==='on'&&!day.ps)
      ? (e.bias==='Heavy' ? ' <span class="badge">▲ +1</span>'
         : (e.bias==='Light' ? ' <span class="badge">▼ −1</span>' : ''))
      : '';
    lines.push({name:nm,repText:repTxt,label});
    remaining -= assign; // exact veelvoud verrekend
  }
}

      // Accessoires
// Accessoires
let advancedCursor = false; // schuiven we de startpositie straks door?
for (const i of accOrder) {
  if (remaining <= 0) break;
  const nm = accList[i]; if (!nm) continue;

  // toewijzen in veelvouden van #rounds (accessoires hebben altijd de standaard cap)
  const maxAccThis = rc.cap * rc.rounds;
  const assignAcc  = Math.min(maxAccThis, takeRoundsLE(remaining, rc.rounds));
  const perRound   = Math.floor(assignAcc / rc.rounds);

  if (perRound <= 0) continue; // geen volume -> geen advance

  const isBall = isBallisticName(nm);
  const isUni  = isUnilateralName(nm);
  const shown  = perRound * (isBall ? 2 : 1);
  const repTxt = isUni ? `${shown}+${shown}` : `${shown}`;

  lines.push({name:nm,repText:repTxt,label:''});
  remaining -= assignAcc;

  // ✅ alleen als er echt volume naar deze accessoire ging, cursor voor multi-accessoire-momenten doordraaien
  advancedCursor = true;
}

// Na deze sessie: als het een multi-accessoire moment was én er is volume gegaan,
// verschuif de cursor zodat de volgende keer de andere accessoire eerst komt.
if (accPick.length > 1 && advancedCursor) {
  const cur = getAccCursor(e.pattern);
  setAccCursor(e.pattern, cur + 1);
}

    }

    // Carry
    const carryEntry=day.entries.find(e=>e.pattern==='Loaded Carry');
    const carryName=shuffle(MATRIX_ADV['Loaded Carry'].acc.slice())[0];
    const carryTxt=carryEntry?`${Math.max(30,carryEntry.volume*5)}s ${carryName}`:`45s ${carryName}`;

    // Compose
    const html=[];
    const doneMark = isDone(w,d) ? ' — ✔' : '';
html.push(esc(`Week ${w+1}, Dag ${d+1}${doneMark}`), '<br><br>');
    if(openerHTML) html.push(openerHTML,'<br><br>');
    html.push('<hr>',esc(`${rc.rounds} rounds of following circuit:`),'<br>');
    if(lines.length){
      html.push(lines.map(o=>`<div class="line"><div class="txt">${esc(o.repText)} ${esc(o.name)}${o.label||''}</div>${mkCounterHTML(`Circuit — ${esc(o.name)}`,rc.rounds)}</div>`).join(''));
    }else{
      html.push(esc('(Geen patronen actief in het circuit vandaag)'));
    }
    html.push('<br><hr><br>',esc(`[ ${carryTxt} ]`));
    document.getElementById('session').innerHTML=html.join('');

    // counter bindings
    document.querySelectorAll('.counter').forEach($c=>{
      const ex=$c.getAttribute('data-ex'); const max=+$c.getAttribute('data-max');
      const $v=$c.querySelector('.cval');
      const upd=()=>{$v.textContent=`${getCount(ex)}/${max}`};
      $c.querySelector('[data-inc]').onclick=()=>{setCount(ex,getCount(ex)+1,max);upd();};
      $c.querySelector('[data-dec]').onclick=()=>{setCount(ex,getCount(ex)-1,max);upd();};
    });
  }

  function renderInfo(){
    if(!state.plan){$('#kpi').innerHTML='';$('#orders').innerHTML='';return;}
    const rc=state.plan.rc;
    const kpi=[
      `<span class="pill">Volume: ${state.cfg.volume}</span>`,
      `<span class="pill">Rounds: ${rc.rounds}</span>`,
      `<span class="pill">Cap/round: ${rc.cap}</span>`,
      `<span class="pill">Blok #${state.blockIdx}</span>`,
      `<span class="pill">KB-bias: ${state.cfg.bias==='on'?'Aan (▲/▼)':'Uit'}</span>`,
      state.cfg.psPattern?`<span class="pill">Plan Strong: ${state.cfg.psPattern} • Vol: ${state.cfg.psVolume} • ${state.cfg.psAdvanced?'Advanced (H+SH)':'Basic'}</span>`:''
    ].filter(Boolean).join(' ');
    document.getElementById('kpi').innerHTML=kpi;
    const rows=Object.entries(state.plan.weekOrders).map(([k,v])=>`${k}: <b>${v.join(' → ')}</b>`).join('<br>');
    document.getElementById('orders').innerHTML=rows;
  }

  // Block controls
  function firstNonEmpty(plan){for(let w=0;w<plan.weeks.length;w++){for(let d=0;d<plan.weeks[w].days.length;d++){if(plan.weeks[w].days[d].entries.length>0||plan.weeks[w].days[d].ps){return{w,d};}}}return{w:0,d:0};}
function newBlock(){
  const cfg=readCfg();
  const plan=buildPlan(cfg);
  const blockIdx=(state.blockIdx||0)+1;
  state={blockIdx,cfg,plan,cursor:firstNonEmpty(plan),lastEnds:state.lastEnds||{}, completed:{}};
  save(); renderInfo(); renderSession(); toast('Blok aangemaakt');
}
  function next(){
    if(!state.plan){newBlock();return;}
    let {w,d}=state.cursor; const weeks=state.plan.weeks;
    d++; if(d>=weeks[w].days.length){d=0; w++;}
    if(w>=weeks.length){
      const ends={}; const matrix=effectiveMatrix();
      for(const pat of Object.keys(matrix)){ ends[pat]=state.plan.weekOrders[pat][3]; }
      state.lastEnds=ends; save(); toast('Blok afgerond'); return;
    }
    state.cursor={w,d}; save(); renderSession();
  }
  function prev(){
    if(!state.plan) return;
    let {w,d}=state.cursor; d--;
    if(d<0){ w--; if(w<0){w=0; d=0;} else { d=state.plan.weeks[w].days.length-1; } }
    state.cursor={w,d}; save(); renderSession();
  }
  function complete(){
  if(!state.plan) return;
  const {w,d} = state.cursor;
  markDone(w,d);
  next();
}
  function resetProgress(){
    localStorage.removeItem(LS_KEY); state={};
    document.getElementById('session').textContent='Voortgang gewist. Klik “Nieuw blok”.';
    document.getElementById('kpi').innerHTML=''; document.getElementById('orders').innerHTML=''; toast('Voortgang gereset');
  }
  function readCfg(){
    const psPatSel=(document.getElementById('selPS').value||''); const on=!!psPatSel;
    return {
      volume:+document.getElementById('selVol').value,
      seed:(document.getElementById('inpSeed').value||'').trim(),
      bias:document.getElementById('selBias').value,
      psPattern: on ? psPatSel : null,
      psVolume:  on ? document.getElementById('selPSVol').value : null,
      psAdvanced:(document.getElementById('chkPSAdvanced') && !document.getElementById('chkPSAdvanced').disabled) ? document.getElementById('chkPSAdvanced').checked : false
    };
  }

  // Tabs
  document.querySelectorAll('.tab-btn').forEach(btn=>{
    btn.onclick=()=>{
      const t=btn.getAttribute('data-tab');
      document.querySelectorAll('.tab-btn').forEach(b=>b.classList.toggle('active',b===btn));
      document.querySelectorAll('.tab-pane').forEach(p=>p.classList.toggle('active',p.id===`tab-${t}`));
    };
  });

  // UI bindings
  document.getElementById('btnNewBlock').onclick=newBlock;
  document.getElementById('btnRebuild').onclick=newBlock;
  document.getElementById('btnReset').onclick=resetProgress;
  document.getElementById('btnNextTop').onclick=()=>next();
  document.getElementById('btnPrevTop').onclick=()=>prev();
  document.getElementById('btnCompleteTop').onclick=complete;

  document.getElementById('selPS').addEventListener('change',(e)=>{
    const on=!!e.target.value;
    document.getElementById('selPSVol').disabled=!on;
    const adv=document.getElementById('chkPSAdvanced'); if(adv) adv.disabled=!on;
  });

  // Custom form
  function renderCustomForm(){
    const wrap=document.getElementById('customForm'); wrap.innerHTML='';
    sanitizeCustom();
    for(const pat of PATTERNS){
      const conf=customMatrix[pat]; const it=conf.items;
      const card=document.createElement('div'); card.className='card';
      const rows=[0,1,2,3].map(i=>{
        const nm=esc(it[i].name||''); const bal=!!it[i].ballistic; const uni=!!it[i].unilateral;
        return `<div class="row-inline">
          <div style="flex:1">
            <label>${i===0?'1 (Main)':' '+(i+1)}</label>
            <input type="text" data-p="${pat}" data-idx="${i}" placeholder="${i===0?'bijv. Military Press':'... (accessoire)'}" value="${nm}">
          </div>
          <label class="chk" style="margin-top:22px"><input type="checkbox" data-p="${pat}" data-idx="${i}" data-bal ${bal?'checked':''}> Ballistic (x2)</label>
          <label class="chk" style="margin-top:22px"><input type="checkbox" data-p="${pat}" data-idx="${i}" data-uni ${uni?'checked':''}> Unilateral (+/+)</label>
        </div>`;
      }).join('');
      card.innerHTML=`<div class="row" style="justify-content:space-between;align-items:center"><b>${pat}</b></div>${rows}`;
      wrap.appendChild(card);
    }
  }
  function readCustomFromForm(){
    const obj=loadJSON(CUSTOM_KEY,{})||{};
    for(const pat of PATTERNS){obj[pat]=obj[pat]||{enabled:true,items:[{},{},{},{}]};}
    document.querySelectorAll('input[data-idx][type="text"]').forEach(inp=>{
      const p=inp.getAttribute('data-p'); const i=+inp.getAttribute('data-idx');
      obj[p].items[i]=obj[p].items[i]||{};
      obj[p].items[i].name = sanitizeName(inp.value);
    });
    document.querySelectorAll('input[data-bal]').forEach(chk=>{
      const p=chk.getAttribute('data-p'); const i=+chk.getAttribute('data-idx');
      obj[p].items[i]=obj[p].items[i]||{}; obj[p].items[i].ballistic=chk.checked;
    });
    document.querySelectorAll('input[data-uni]').forEach(chk=>{
      const p=chk.getAttribute('data-p'); const i=+chk.getAttribute('data-idx');
      obj[p].items[i]=obj[p].items[i]||{}; obj[p].items[i].unilateral=chk.checked;
    });
    return obj;
  }

  renderCustomForm();

  // Custom buttons
  document.getElementById('btnSaveCustom').onclick=()=>{
    customMatrix=readCustomFromForm(); saveJSON(CUSTOM_KEY,customMatrix);
    document.querySelector('.tab-btn[data-tab="plan"]').click();
    newBlock(); toast('Eigen oefeningen opgeslagen');
  };
  document.getElementById('btnClearCustom').onclick=()=>{
    customMatrix={}; saveJSON(CUSTOM_KEY,customMatrix); renderCustomForm(); toast('Eigen oefeningen geleegd');
  };

  // Restore
  if(state&&state.plan){renderInfo();renderSession();}

})();
</script>
</body>
</html>
