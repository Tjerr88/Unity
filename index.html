<!doctype html>
<html lang="nl">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Unity 2025</title>
<!-- Unity 2025 — FINAL BUILD f4h (2025-10-28)
     - Fix: geldige esc(); geen dubbele helpers/vars
     - Set-tellers: opener + alle circuit-items, per dag (localStorage)
     - Opener teller rechts uitgelijnd; counters schalen mee (500-blok => 5)
     - Custom-oefeningen tab met per-patroon override + ballistic (x2)
     - Plan Strong: koppelt aan patroon-main (KB of eigen override)
     - Barbell integratie verwijderd
-->
<style>
  :root{color-scheme:dark}
  *{box-sizing:border-box}
  body{margin:0;background:#0b1220;color:#e6eaf2;font:16px/1.6 system-ui,Arial}
  .app{max-width:980px;margin:0 auto;padding:16px 12px 84px}
  h1{margin:0 0 .6rem;font-size:28px}
  h2{margin:0;font-size:18px}
  .btn{background:#2b63ff;border:0;color:#fff;padding:12px 14px;border-radius:12px;cursor:pointer;font-weight:800;transition:transform .06s ease,filter .15s ease;-webkit-tap-highlight-color:transparent}
  .btn.ghost{background:#1a2a4a}
  .btn.inline{padding:10px 12px;border-radius:10px}
  .btn:active{transform:translateY(1px)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .row.stack>*.btn{flex:1}
  .card{background:#101a30;border:1px solid rgba(255,255,255,.08);border-radius:14px;padding:12px;margin:10px 0}
  .session{white-space:pre-wrap;background:#0e182c;border:1px solid rgba(255,255,255,.12);border-radius:14px;padding:16px;line-height:1.7;font-family:ui-monospace,monospace;font-size:clamp(13px,1.9vw,16px)}
  .pill{display:inline-block;background:#182446;border-radius:999px;padding:5px 12px;font-size:12px;margin:3px 3px 0 0}
  details{border:1px solid rgba(255,255,255,.08);border-radius:12px}
  summary{list-style:none;cursor:pointer;padding:12px;font-weight:800;background:#0f1a34;border-radius:12px}
  summary::-webkit-details-marker{display:none}
  details[open]>summary{border-bottom:1px solid rgba(255,255,255,.08);border-bottom-left-radius:0;border-bottom-right-radius:0}
  .panel{padding:12px}
  label{font-size:12px;opacity:.88;display:block;margin:8px 0 4px}
  select,input[type="text"]{width:100%;background:#0d1830;border:1px solid rgba(255,255,255,.18);color:#e6eaf2;padding:10px;border-radius:10px}
  .grid{display:grid;gap:10px}
  .cols-2{grid-template-columns:repeat(2,minmax(0,1fr))}
  @media (max-width:760px){
    .cols-2{grid-template-columns:1fr}
    .row.stack{display:grid;grid-template-columns:1fr;gap:8px}
    .btn{padding:14px 16px;border-radius:14px}
  }
  .muted{opacity:.75;font-size:12px}
  .toast{position:fixed;inset:auto 12px 12px auto;background:#0f1a34;border:1px solid rgba(255,255,255,.15);padding:10px 12px;border-radius:12px;font-size:13px}
  .diag{position:fixed;left:12px;bottom:12px;background:#0f1a34;border:1px solid rgba(255,255,255,.2);padding:8px 10px;border-radius:10px;font:12px/1.4 ui-monospace,monospace;max-width:44ch;max-height:30vh;overflow:auto;display:none}
  .diag b{color:#b8f0c2}
  .badge{display:inline-block;font-weight:800;font-size:12px;padding:3px 8px;border-radius:10px;border:1px solid rgba(255,255,255,.25);margin-left:6px;background:#0f1a34;color:#e6eaf2}
  .tabs{display:flex;gap:8px;margin:10px 0 6px}
  .tab-btn{background:#0f1a34;border:1px solid rgba(255,255,255,.15);color:#e6eaf2;padding:10px 12px;border-radius:12px;font-weight:800;cursor:pointer}
  .tab-btn.active{background:#2b63ff;border-color:#2b63ff}
  .tab-pane{display:none}
  .tab-pane.active{display:block}

  /* Counters */
  .counter{display:inline-flex;align-items:center;gap:8px;margin-left:12px;flex:0 0 auto}
  .counter .cbtn{background:#0f1a34;border:1px solid rgba(255,255,255,.2);color:#e6eaf2;border-radius:10px;padding:4px 10px;font-weight:800;cursor:pointer}
  .counter .cval{min-width:64px;text-align:center;font-weight:900}
  .counter .cbtn:active{transform:translateY(1px)}
  .session .line{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:nowrap}
  .session .line .txt{flex:1;min-width:0;white-space:normal}
  .row-inline{display:flex;gap:8px;align-items:center}
  .row-inline input[type="text"]{flex:1}
  .chk{display:inline-flex;gap:6px;align-items:center;font-size:12px;opacity:.9}
</style>
</head>
<body>
<div class="app">

  <h1>Unity 2025</h1>

  <div class="tabs" role="tablist" aria-label="Navigatie">
    <button class="tab-btn active" data-tab="plan" aria-selected="true">Planner</button>
    <button class="tab-btn" data-tab="custom" aria-selected="false">Eigen oefeningen</button>
  </div>

  <div id="tab-plan" class="tab-pane active">

    <div class="row stack" style="margin:8px 0 12px">
      <button id="btnPrevTop" class="btn ghost" aria-label="Vorige sessie">◀ Vorige</button>
      <button id="btnNextTop" class="btn" aria-label="Volgende sessie">Volgende ▶</button>
      <button id="btnCompleteTop" class="btn inline" title="Markeer deze sessie als voltooid">Complete ✔</button>
      <button id="btnNewBlock" class="btn inline" title="Nieuw blok (zet alles opnieuw)">Nieuw blok</button>
    </div>

    <div class="card">
      <h2>Huidige sessie</h2>
      <div id="session" class="session" aria-live="polite">Nog geen blok. Klik op “Nieuw blok”.</div>
    </div>

    <details id="accSettings">
      <summary>Instellingen</summary>
      <div class="panel">
        <div class="grid cols-2">
          <div>
            <label>Blokvolume (Unity)</label>
            <select id="selVol">
              <option>180</option><option>240</option><option selected>300</option><option>400</option><option>500</option>
            </select>
          </div>
          <div>
            <label>Seed (optioneel)</label>
            <input id="inpSeed" placeholder="bv. 12345">
          </div>

          <div>
            <label>Oefeningsset</label>
            <select id="selSet">
              <option value="advanced" selected>Advanced</option>
              <option value="basic">Basis (geen double bells / snatch / bent press / jerk)</option>
            </select>
          </div>

          <div>
            <label>KB-bias (alleen mains; op basis van week-split)</label>
            <select id="selBias">
              <option value="on" selected>Aan (▲/▼)</option>
              <option value="off">Uit</option>
            </select>
          </div>

          <div>
            <label>Plan Strong overlay (1 grind-patroon)</label>
            <select id="selPS">
              <option value="">— Uit —</option>
              <option>Push</option><option>Pull</option><option>Squat</option><option>Hinge</option>
            </select>
          </div>
          <div>
            <label>PS Volume (indien PS aan)</label>
            <select id="selPSVol" disabled>
              <option>180</option><option selected>240</option><option>300</option>
            </select>
          </div>
          <div>
            <label>PS-modus</label>
            <label class="row" style="gap:10px">
              <input type="checkbox" id="chkPSAdvanced" disabled>
              <span>Advanced: High + Super Heavy</span>
            </label>
          </div>

          <div>
            <label>Chaos mode (notities/accordeon per oefening)</label>
            <select id="selChaos">
              <option value="off" selected>Uit</option>
              <option value="on">Aan</option>
            </select>
          </div>
        </div>

        <div class="card" style="margin-top:12px">
          <div id="kpi"></div>
          <div id="orders" class="muted" style="margin-top:6px"></div>
          <div class="muted" style="margin-top:6px">
            Weekpercentages: Deload 15% • Maintenance 22% • Development 28% • Stress 35%.<br>
            Splits per partitie: 3 → [15,35,50]% • 4 → [15,22,28,35]% • 5 → [10,15,20,25,30]%.<br>
            Bias (alleen mains): Deload min%=Heavy ▲, max%=Light ▼ • Maint/Dev min%=Heavy ▲, max%=Light ▼ • Stress min%=Heavy ▲, max%=Light ▼.<br>
            Light-bias main: cap-boost tot 10 per ronde (geen PS).<br>
            Plan Strong: 3×/week <b>M→H→L</b> (Advanced = <b>H+SH</b>); volgorde weken vast: Deload → Development → Maintenance → Stress.<br>
            Anti-Rotation main: altijd Snatch.
          </div>
        </div>

        <div class="row stack" style="margin-top:8px">
          <button id="btnRebuild" class="btn">Instellingen toepassen</button>
          <button id="btnReset" class="btn ghost">Reset voortgang</button>
          <button id="btnResetCounters" class="btn ghost" title="Wis set-tellers van deze sessie">Reset tellers</button>
        </div>
      </div>
    </details>

  </div> <!-- einde tab-plan -->

  <div id="tab-custom" class="tab-pane">
    <div class="card">
      <h2>Eigen oefeningen</h2>
      <p class="muted">Per patroon: zet <b>Override gebruiken</b> aan om de standaard matrix te overschrijven. Veld <b>1 = Main</b>, 2–4 = accessoires. Zet <b>Ballistic (x2)</b> aan voor oefeningen waarbij elke herhaling als x2 telt (zoals Swings/Snatches).</p>
      <div id="customForm" class="grid cols-2" style="margin-top:8px"></div>
      <div class="row stack" style="margin-top:8px">
        <button id="btnSaveCustom" class="btn">Opslaan</button>
        <button id="btnClearCustom" class="btn ghost">Leegmaken</button>
        <span class="muted">Na opslaan: ga naar Planner → Instellingen → “Instellingen toepassen”.</span>
      </div>
    </div>
  </div>

</div>

<div id="toast" class="toast" style="display:none" aria-live="polite"></div>
<div id="diag" class="diag"></div>

<script>
(function(){
  const SPEC_VERSION='2025-10-28_f4h';

  // ===== Diagnostics =====
  const diagEl = document.getElementById('diag');
  function diag(msg){ diagEl.style.display='block'; diagEl.innerHTML = '<b>Diagnostics</b><br>'+String(msg).replace(/</g,'&lt;'); }
  window.addEventListener('error', e=>diag(e.message+'\n'+(e.filename||'')+':'+(e.lineno||'')));

  // ===== Keys & consts =====
  const LS_KEY='unity2025_state';
  const NOTES_KEY='unity2025_notes';
  const COUNTERS_KEY='unity2025_counters';
  const CUSTOM_KEY='unity2025_custom_matrix_v2';
  const PATTERNS=['Push','Pull','Squat','Lunge','Hinge','Rotation','Anti-Rotation','Loaded Carry'];
  const WEEK_TYPES=['Deload','Maintenance','Development','Stress'];
  const WEEK_PCT={Deload:.15,Maintenance:.22,Development:.28,Stress:.35};
  const SPLITS = { 3:[0.15,0.35,0.50], 4:[0.15,0.22,0.28,0.35], 5:[0.10,0.15,0.20,0.25,0.30] };
  const DEFAULT_BALLISTICS = new Set(['Snatch','One-arm Swing','Two-arm Swing','High Pull','Double Clean']);

  // ===== Matrices =====
  const MATRIX_ADV = {
    'Push': { main:'Military Press', acc:['Push Press','Half-kneeling Press','Floor Press'] },
    'Pull': { main:'Double Clean', acc:['Pull-up / Chin-up','Double Bent-over Row','High Pull'] },
    'Squat': { main:'Double Front Squat', acc:['Goblet Squat','Bulgarian Split Squat','Step-up'] },
    'Lunge': { main:'Tactical Lunge', acc:['Double Reverse Lunge','Athletic Lunge','Side Lunge'] },
    'Hinge': { main:'Two-arm Swing', acc:['Single-leg Glute Bridge','Double Deadlift','Double Snatch'] },
    'Rotation': { main:'Turkish Get Up', acc:['Windmill','Half-kneeling Windmill','Bent Press'] },
    'Anti-Rotation': { main:'Snatch', acc:['One-arm Swing','Single-leg Deadlift','Renegade Row'] },
    'Loaded Carry': { main:'Suitcase Carry', acc:['Front Rack Carry','Overhead Carry','Bear Crawl'] }
  };
  const MATRIX_BASIC = {
    'Push': { main:'Military Press', acc:['Half-kneeling Press','Floor Press','Push Press'] },
    'Pull': { main:'One-arm Row', acc:['Gorilla Row','One-arm Clean','High Pull'] },
    'Squat': { main:'Goblet Squat', acc:['Step-up','Split Squat','Bodyweight Squat'] },
    'Lunge': { main:'Reverse Lunge', acc:['Tactical Lunge','Forward Lunge','Side Lunge'] },
    'Hinge': { main:'Two-arm Swing', acc:['KB Deadlift','Single-leg Glute Bridge','Hip Hinge (BW)'] },
    'Rotation': { main:'Turkish Get Up', acc:['Half-kneeling Windmill','Windmill','Tall-kneeling Windmill'] },
    'Anti-Rotation': { main:'Snatch', acc:['One-arm Swing','Single-leg Deadlift','Pallof Press (band)'] },
    'Loaded Carry': { main:'Suitcase Carry', acc:['Front Rack Carry','Farmer Carry','Bear Crawl'] }
  };

  // ===== Helpers =====
  const $=s=>document.querySelector(s);
  const toast=(m)=>{ const t=$('#toast'); t.textContent=m; t.style.display='block'; setTimeout(()=>t.style.display='none',1600); };
  function esc(s){
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }
  function makeRNG(seedStr){ let h=2166136261>>>0; if(seedStr){ for(let i=0;i<seedStr.length;i++){ h^=seedStr.charCodeAt(i); h=Math.imul(h,16777619); } } else { h=(Date.now()>>>0); } return function(){ h+=0x6D2B79F5; let t=h; t=Math.imul(t^t>>>15, t|1); t^=t+Math.imul(t^t>>>7, t|61); return ((t^t>>>14)>>>0)/4294967296; } }
  let rnd = makeRNG('');
  function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(rnd()*(i+1)); [a[i],a[j]]=[a[j],a[i]] } return a; }
  const clean = s => String(s).replace(/\s+/g,' ').trim();
  const choice=a=>a[Math.floor(rnd()*a.length)];
  function roundsCap(vol){ switch(+vol){ case 180:return{rounds:3,cap:3}; case 240:return{rounds:3,cap:4}; case 300:return{rounds:3,cap:5}; case 400:return{rounds:4,cap:5}; case 500:return{rounds:5,cap:5}; default:return{rounds:3,cap:5}; } }
  function isUni(name){ const n=clean(name).toLowerCase(); if(n.includes('double')||n.includes('two-arm')||n.includes('front squat')||n.includes('deadlift ')||n.includes('goblet')||n.includes('carry')) return false;
    if(n.includes('one-arm')||n.includes('single-leg')||n.includes('lunge')||n.includes('windmill')||n.includes('bent press')||n.includes('side swing')||n.includes('renegade row')||n.includes('pull-up')||n.includes('chin-up')||n.includes('military press')||n.includes('push press')||n.includes('snatch')) return true; return false; }
  function badge(kind){ if(kind==='Heavy') return ' <span class="badge" title="Heavy (+1 bell)" aria-label="Heavy (+1 bell)">▲ +1</span>'; if(kind==='Light') return ' <span class="badge" title="Light (−1 bell)" aria-label="Light (−1 bell)">▼ −1</span>'; return ''; }
  function apportion2(total, weights){ const w=weights.slice(); const W=w.reduce((a,b)=>a+b,0); if(W<=0) return Array(w.length).fill(0); const raw=w.map(v=>(v*total)/W); const base=raw.map(x=>Math.floor(x)); let rem= total - base.reduce((a,b)=>a+b,0);
    const order=raw.map((x,i)=>({i,frac:x-Math.floor(x)})).sort((a,b)=>b.frac-a.frac); for(let k=0;k<order.length && rem>0;k++){ base[order[k].i]+=1; rem--; } return base; }

  // Notes
  function loadNotes(){ try{ return JSON.parse(localStorage.getItem(NOTES_KEY)||'{}') }catch(e){ return {} } }
  function saveNotes(obj){ try{ localStorage.setItem(NOTES_KEY, JSON.stringify(obj)) }catch(e){} }
  let notes = loadNotes();
  function getNote(exName){ return notes[exName]||'' }
  function setNote(exName, val){ notes[exName]=val; saveNotes(notes); }

  // Counters
  function countersLoad(){ try{ return JSON.parse(localStorage.getItem(COUNTERS_KEY) || '{}'); }catch(e){ return {}; } }
  function countersSave(obj){ try{ localStorage.setItem(COUNTERS_KEY, JSON.stringify(obj)); }catch(e){} }
  let counters = countersLoad();
  function dayKey(){ if(!state.plan || !state.cursor) return 'nokey'; const {w,d}=state.cursor; return `${state.blockIdx||0}_${w}_${d}`; }
  function getCount(exKey){ const k=dayKey(); return (counters[k] && counters[k][exKey])|0; }
  function setCount(exKey, val, max){ const k=dayKey(); counters[k]=counters[k]||{}; counters[k][exKey]=Math.max(0, Math.min(max,val|0)); countersSave(counters); }
  function resetDayCounters(){ const k=dayKey(); if(counters[k]){ delete counters[k]; countersSave(counters); } }

  // Custom matrix
  function loadCustom(){ try{ return JSON.parse(localStorage.getItem(CUSTOM_KEY) || '{}'); }catch(e){ return {}; } }
  function saveCustom(obj){ try{ localStorage.setItem(CUSTOM_KEY, JSON.stringify(obj)); }catch(e){} }
  let customMatrix = loadCustom();

  function customBallisticSet(){
    const set=new Set();
    for(const [pat,conf] of Object.entries(customMatrix||{})){
      if(!conf || !conf.enabled) continue;
      (conf.items||[]).forEach(it=>{
        if(it && it.name && it.ballistic){ set.add(clean(it.name)); }
      });
    }
    return set;
  }
  function isBallistic(name){
    const nm = clean(name);
    return DEFAULT_BALLISTICS.has(nm) || customBallisticSet().has(nm);
  }
  function mkCounterHTML(exKey, max, current){
    const safeKey = exKey.replace(/&/g,'&amp;').replace(/</g,'&lt;');
    return `
      <span class="counter" data-ex="${safeKey}" data-max="${max}">
        <button class="cbtn" data-dec>−</button>
        <span class="cval">${current}/${max}</span>
        <button class="cbtn" data-inc>+</button>
      </span>`;
  }

  // ===== State =====
  let state = safeLoad() || {};
  function safeLoad(){ try{ return JSON.parse(localStorage.getItem(LS_KEY)||'null') }catch(e){ diag('load error: '+e.message); return null } }
  function save(){ try{ localStorage.setItem(LS_KEY, JSON.stringify(state)) }catch(e){ diag('save error: '+e.message) } }

  // ===== Splits helpers =====
  function buildWeekSplitsWithPcts(blockVol, weekType){
    const parts = (weekType==='Deload') ? 3 : (weekType==='Stress' ? 5 : 4);
    const basePcts = SPLITS[parts].slice();
    const {rounds} = roundsCap(blockVol);
    const weekTotal = Math.round(blockVol * (WEEK_PCT[weekType] || 0));
    let sess = basePcts.map(p => Math.max(rounds, Math.round((weekTotal * p) / rounds) * rounds));
    let diff = weekTotal - sess.reduce((a,b)=>a+b,0);
    let idx = sess.length - 1;
    while (Math.abs(diff) >= rounds) {
      if (diff > 0) { sess[idx] += rounds; diff -= rounds; }
      else if (sess[idx] - rounds >= rounds) { sess[idx] -= rounds; diff += rounds; }
      else { if (idx > 0) { idx--; continue; } break; }
    }
    const orderIdx = sess.map((_,i)=>i); shuffle(orderIdx);
    return orderIdx.map(i => ({ vol: sess[i], pct: basePcts[i] }));
  }
  function biasFromPct(weekType, pct){
    const parts = (weekType==='Deload') ? 3 : (weekType==='Stress' ? 5 : 4);
    const base = SPLITS[parts]; const minPct = Math.min(...base); const maxPct = Math.max(...base);
    const eq = (a,b)=> Math.abs(a-b) < 1e-9;
    if (eq(pct, minPct)) return 'Heavy';
    if (eq(pct, maxPct)) return 'Light';
    return 'Medium';
  }
  function pickDays(count){ const d=[0,1,2,3,4]; shuffle(d); return d.slice(0,count).sort((a,b)=>a-b); }

  // ===== Effective matrix with per-pattern override =====
  function effectiveMatrix(cfg){
    const base = (cfg.set==='basic') ? MATRIX_BASIC : MATRIX_ADV;
    const out = JSON.parse(JSON.stringify(base));
    if(out['Anti-Rotation']) out['Anti-Rotation'].main = 'Snatch';
    for(const pat of PATTERNS){
      const conf = customMatrix[pat];
      if(!conf || !conf.enabled) continue;
      const items = (conf.items||[]);
      const merged = [];
      for(let i=0;i<4;i++){
        const it = items[i] || {name:'', ballistic:false};
        if(it.name && it.name.trim()) merged[i]=it.name.trim();
        else merged[i] = (i===0) ? out[pat].main : (out[pat].acc[i-1] || '');
      }
      out[pat] = { main: merged[0], acc: merged.slice(1).filter(Boolean) };
    }
    return out;
  }

  // ===== Planbouw =====
  function buildPlan(cfg){
    rnd = makeRNG(cfg.seed||'');
    const matrix = effectiveMatrix(cfg);

    const lastEnds = state.lastEnds || {};
    const weekOrders = {};
    for(const pat of Object.keys(matrix)){
      const order=['Deload','Maintenance','Development','Stress']; shuffle(order);
      if(lastEnds[pat] && order[0]===lastEnds[pat]){ [order[0],order[1]]=[order[1],order[0]]; }
      weekOrders[pat]=order;
    }

    const weeks = Array.from({length:4}, ()=>({days:Array.from({length:5},()=>({entries:[],ps:null}))}));

    for(const [pat,def] of Object.entries(matrix)){
      for(let w=0; w<4; w++){
        const wt = weekOrders[pat][w];
        const items = buildWeekSplitsWithPcts(cfg.volume, wt);
        const dayIdxs = pickDays(items.length);
        for(let i=0;i<items.length;i++){
          const d = dayIdxs[i];
          const {vol, pct} = items[i];
          weeks[w].days[d].entries.push({
            pattern: pat, main: def.main, acc: def.acc.slice(),
            weekType: wt, volume: vol, pct: pct, bias: biasFromPct(wt, pct)
          });
        }
      }
    }

    // Plan Strong — 3×/week (M→H→L), vaste volgorde Deload→Development→Maintenance→Stress
    if(cfg.psPattern){
      const psPat   = cfg.psPattern;
      const psBlock = +cfg.psVolume;
      const fixedOrder = ['Deload','Development','Maintenance','Stress'];

      for(let w=0; w<4; w++){
        const wt = fixedOrder[w];
        const weekVol = Math.round(psBlock * (WEEK_PCT[wt] || 0));

        // verwijder PS-patroon die week
        for(let dd=0; dd<5; dd++){
          weeks[w].days[dd].entries = weeks[w].days[dd].entries.filter(en => en.pattern !== psPat);
        }

        const dayIdxs = pickDays(3);
        let weights = [50,35,15]; let labels = ['Medium','High','Low']; let shOnHigh=false;
        if(cfg.psAdvanced){ weights=[30,55,15]; shOnHigh=true; }
        const sessVols = apportion2(weekVol, weights);

        const psMainName = (matrix[psPat] && matrix[psPat].main) ? matrix[psPat].main : psPat;

        for(let i=0;i<3;i++){
          const d = dayIdxs[i];
          weeks[w].days[d].ps = weeks[w].days[d].ps || {};
          weeks[w].days[d].ps[psPat] = {
            weekType: wt,
            reps: sessVols[i],
            mainName: psMainName,
            level: labels[i],
            sh: (labels[i]==='High' && shOnHigh),
            mode: cfg.psAdvanced ? 'advanced' : 'basic'
          };
        }
      }
    }

    return {weeks, rc:roundsCap(cfg.volume), weekOrders, set: cfg.set};
  }

  // ===== EMOM =====
  function buildEMOM(assigned){
    const wantShown = 10;
    const has = new Map();
    for(const a of assigned){
      const nm=clean(a.name);
      if(['Snatch','One-arm Swing','Two-arm Swing'].includes(nm) && a.shownPerRound === wantShown){
        has.set(nm,true);
      }
    }
    if(has.size < 2) return null;
    const order=['Snatch','One-arm Swing','Two-arm Swing'];
    const parts=[]; const used=[];
    for(const nm of order){
      if(!has.has(nm)) continue;
      used.push(nm);
      if(nm==='Two-arm Swing'){
        parts.push(`EMOM:\n3 minutes of 10 Two-arm Swings (30 totaal = 3 min)`);
      }else{
        const label = nm==='Snatch'?'Snatches':'One-arm Swings';
        parts.push(`EMOM:\n6 minutes of 10 ${label} (alternate side each minute)\n\nThen`);
      }
    }
    let text = parts.join('\n\n').replace(/\n\nThen$/,'');
    return { text, _names: used };
  }

  // ===== Rendering sessie =====
  function renderSession(){
    try{
      const out = $('#session');
      if(!state.plan){ out.textContent='Nog geen blok. Klik op “Nieuw blok”.'; return; }

      const {w,d} = state.cursor;
      const day = state.plan.weeks[w].days[d];
      const rc = state.plan.rc;

      // Opener
      let openerHTML='';
      const rot = day.entries.find(e=>e.pattern==='Rotation');
      if(rot){
        const setsByBlock = rc.rounds;
        const costPerSet = rc.cap;
        const totalCost = setsByBlock * costPerSet;
        const showTwoTwo = (state.cfg.bias==='on' && (rot.bias||'Medium')==='Light');
        const exKeyOp = `Opener — Turkish Get Up`;
        const cur = getCount(exKeyOp);
        const line = `${setsByBlock} × (${showTwoTwo? '2+2':'1+1'}) Turkish Get Up`;
        openerHTML = `<div class="line"><div class="txt">${line}</div>${mkCounterHTML(exKeyOp, setsByBlock, cur)}</div>`;
        rot.volume = Math.max(0, (rot.volume|0) - totalCost);
      }

      // Circuit
      const assigned=[];
      const entries = shuffle(day.entries.slice().filter(e=> e.pattern!=='Loaded Carry'));
      const lineObjs=[];

      for(const e of entries){
        const mainName = e.main;
        let order;
        if (e.pattern === 'Rotation') {
          order = [...(e.acc || [])].filter(Boolean);
        } else {
          order = [mainName, ...(e.acc||[])].filter(Boolean);
        }

        const seen = new Set();
        let remaining = e.volume;
        let usedCount=0;

        for(let i=0; i<order.length && remaining>0 && usedCount<3; i++){
          const nm = clean(order[i]);
          if(seen.has(nm)) continue;
          seen.add(nm);

          let perRound = Math.min(rc.cap, Math.ceil(remaining/rc.rounds));
          perRound = Math.max(1, Math.floor(perRound));

          const isMainLine = (nm===clean(mainName));
          const lightBoost = (state.cfg.bias==='on' && e.bias==='Light' && isMainLine && !day.ps);
          if(lightBoost){ perRound = Math.min(10, Math.max(perRound, rc.cap)); }

          const ball = isBallistic(nm);
          const uni = isUni(nm);
          const shown = perRound * (ball?2:1);
          const repText = uni ? `${shown}+${shown}` : `${shown}`;

          let labelHTML = '';
          if(isMainLine && state.cfg.bias==='on' && !day.ps){
            labelHTML = (e.bias==='Heavy') ? badge('Heavy') : (e.bias==='Light') ? badge('Light') : '';
          }

          lineObjs.push({name:nm, repText, htmlLabel:labelHTML, isMain:isMainLine});
          const totalUnity = perRound * rc.rounds;
          assigned.push({name:nm,totalUnity,shownPerRound:shown});
          remaining -= totalUnity; usedCount++;
        }

        // Filler indien rest
        if(remaining > 0){
          const fillerName = order[Math.min(2, order.length-1)] || order[0];
          let safety=16;
          while(remaining>0 && safety--){
            let perRound = Math.max(1, Math.min(rc.cap, Math.ceil(remaining/rc.rounds)));
            const ball = isBallistic(fillerName);
            const uni = isUni(fillerName);
            const shown = perRound * (ball?2:1);
            const repText = uni ? `${shown}+${shown}` : `${shown}`;
            lineObjs.push({name:fillerName, repText, htmlLabel:'', isMain:false});
            const totalUnity = perRound * rc.rounds;
            assigned.push({name:fillerName,totalUnity,shownPerRound:shown});
            remaining -= totalUnity;
          }
        }
      }

      // PS inject
      if(day.ps){
        const injected=[];
        for(const [pat,info] of Object.entries(day.ps)){
          const T = Math.max(0, info.reps|0);
          const labels = (info.mode==='advanced'||info.sh)?['L','M','H','SH']:['L','M','H'];
          const weights = (labels.length===4)?[45,30,20,5]:[50,35,15];
          const buckets = apportion2(T, weights);
          const rounds = state.plan.rc.rounds;
          const roundsWeights = Array(rounds).fill(1);
          const perRound = buckets.map(v => apportion2(v, roundsWeights));
          const roundLabels=[];
          for (let r=0;r<rounds;r++){
            const parts=[];
            for(const pr of labels){
              const idx = labels.indexOf(pr);
              if (idx>=0 && perRound[idx][r]>0) parts.push(`${pr}${perRound[idx][r]}`);
            }
            roundLabels.push(parts.length?parts.join('/'):'—');
          }
          const detail = roundLabels.map((s,i)=>`R${i+1}:${s}`).join(' • ');
          injected.push({
            name:`PS — ${info.mainName}`,
            repText:`${rounds} rounds`,
            htmlLabel:` — ${info.level || 'Medium'}${info.sh?' (H+SH)':''} — ${detail}`,
            isMain:true
          });
        }
        if(injected.length){ lineObjs.unshift(...injected); }
      }

      // EMOM
      const emom = buildEMOM(assigned);
      let circuitObjs = lineObjs.slice();
      if(emom){
        const drop = new Set(emom._names.map(clean));
        circuitObjs = circuitObjs.filter(o => !drop.has(clean(o.name)));
      }

      // Carry
      const carryName = (choice((state.plan.set==='basic'?MATRIX_BASIC:MATRIX_ADV)['Loaded Carry'].acc));
      const carryEntry = day.entries.find(e=>e.pattern==='Loaded Carry');
      const carryTxt = carryEntry ? `${Math.max(30, carryEntry.volume*5)}s ${carryName}` : `45s ${carryName}`;

      // Compose
      const parts = [];
      parts.push(esc(`Week ${w+1}, Dag ${d+1}`), '<br><br>');
      if(openerHTML){ parts.push(openerHTML, '<br><br>'); }
      parts.push('<hr>');
      parts.push(esc(`${rc.rounds} rounds of following circuit:`), '<br>');

      if(circuitObjs.length){
        const lines = circuitObjs.map(o=>{
          const exKey = `Circuit — ${o.name}`;
          const cur = getCount(exKey);
          const max = rc.rounds;
          return `<div class="line"><div class="txt">${esc(o.repText)} ${esc(o.name)}${o.htmlLabel}</div>${mkCounterHTML(exKey, max, cur)}</div>`;
        }).join('');
        parts.push(lines, '<br>');
      }else{
        parts.push(esc('(Geen patronen actief in het circuit vandaag)'), '<br>');
      }

      parts.push('<hr><br>');
      if(emom){ parts.push(esc(emom.text).replace(/\n/g,'<br>'), '<br><hr><br>'); }
      parts.push(esc(`[ ${carryTxt} ]`));

      $('#session').innerHTML = parts.join('');

      // Bind counters
      document.querySelectorAll('.counter').forEach($c=>{
        const ex = $c.getAttribute('data-ex');
        const max = +$c.getAttribute('data-max');
        const $val=$c.querySelector('.cval');
        const upd=()=>{ $val.textContent = `${getCount(ex)}/${max}`; };
        const inc=$c.querySelector('[data-inc]');
        const dec=$c.querySelector('[data-dec]');
        if(inc) inc.onclick=()=>{ setCount(ex, getCount(ex)+1, max); upd(); };
        if(dec) dec.onclick=()=>{ setCount(ex, getCount(ex)-1, max); upd(); };
      });

    }catch(e){ diag('renderSession error: '+e.message); }
  }

  // ===== Info render =====
  function renderInfo(){
    try{
      if(!state.plan){ $('#kpi').innerHTML=''; $('#orders').innerHTML=''; return; }
      const rc = state.plan.rc;
      const kpi = [
        `<span class="pill">Set: ${state.cfg.set==='basic'?'Basis':'Advanced'}</span>`,
        `<span class="pill">Volume: ${state.cfg.volume}</span>`,
        `<span class="pill">Rounds: ${rc.rounds}</span>`,
        `<span class="pill">Cap/round: ${rc.cap}</span>`,
        `<span class="pill">Blok #${state.blockIdx}</span>`,
        `<span class="pill">KB-bias: ${state.cfg.bias==='on'?'Aan (▲/▼)':'Uit'}</span>`,
        state.cfg.psPattern? `<span class="pill">Plan Strong: ${state.cfg.psPattern} • Vol: ${state.cfg.psVolume} • ${state.cfg.psAdvanced?'Advanced (H+SH)':'Basic'}</span>`:''
      ].filter(Boolean).join(' ');
      $('#kpi').innerHTML = kpi;

      const rows = Object.entries(state.plan.weekOrders).map(([k,v])=>`${k}: <b>${v.join(' → ')}</b>`).join('<br>');
      $('#orders').innerHTML = rows;
    }catch(e){ diag('renderInfo error: '+e.message); }
  }

  // ===== Blok besturing =====
  function firstNonEmpty(plan){
    for(let w=0; w<plan.weeks.length; w++){
      for(let d=0; d<plan.weeks[w].days.length; d++){
        if(plan.weeks[w].days[d].entries.length>0 || plan.weeks[w].days[d].ps){ return {w,d}; }
      }
    }
    return {w:0,d:0};
  }
  function newBlock(){
    try{
      const cfg = readCfg();
      const plan = buildPlan(cfg);
      const blockIdx = (state.blockIdx||0)+1;
      state = { blockIdx, cfg, plan, cursor: firstNonEmpty(plan), lastEnds: state.lastEnds || {} };
      save(); renderInfo(); renderSession(); toast('Blok aangemaakt');
    }catch(e){ diag('newBlock error: '+e.message); }
  }
  function next(){
    if(!state.plan){ newBlock(); return; }
    let {w,d} = state.cursor;
    const weeks = state.plan.weeks;
    d++; if(d>=weeks[w].days.length){ d=0; w++; }
    if(w>=weeks.length){
      const matrix = effectiveMatrix(state.cfg);
      const ends={}; for(const pat of Object.keys(matrix)){ ends[pat] = state.plan.weekOrders[pat][3]; }
      state.lastEnds=ends; save(); toast('Blok afgerond'); return;
    }
    state.cursor={w,d}; save(); renderSession();
  }
  function prev(){
    if(!state.plan) return;
    let {w,d} = state.cursor;
    d--; if(d<0){ w--; if(w<0){w=0; d=0;} else { d = state.plan.weeks[w].days.length-1; } }
    state.cursor={w,d}; save(); renderSession();
  }
  function complete(){ next(); }
  function resetProgress(){
    try{
      localStorage.removeItem(LS_KEY);
      state={};
      $('#session').textContent='Voortgang gewist. Klik “Nieuw blok”.';
      $('#kpi').innerHTML=''; $('#orders').innerHTML='';
      toast('Voortgang gereset');
    }catch(e){ diag('reset error: '+e.message); }
  }

  function readCfg(){
    const psPatSel = ($('#selPS').value||'');
    const psPat = psPatSel ? psPatSel : null;
    const psVol = $('#selPSVol').value;
    return {
      set: $('#selSet').value,
      volume: +$('#selVol').value,
      seed: ($('#inpSeed').value||'').trim(),
      bias: $('#selBias').value,
      psPattern: psPat,
      psVolume: psPat ? psVol : null,
      psAdvanced: (document.getElementById('chkPSAdvanced') && !document.getElementById('chkPSAdvanced').disabled) ? document.getElementById('chkPSAdvanced').checked : false,
      chaos: $('#selChaos').value
    };
  }

  // ===== Tabs =====
  document.querySelectorAll('.tab-btn').forEach(btn=>{
    btn.onclick=()=>{
      const target = btn.getAttribute('data-tab');
      document.querySelectorAll('.tab-btn').forEach(b=>b.classList.toggle('active', b===btn));
      document.querySelectorAll('.tab-pane').forEach(p=>p.classList.toggle('active', p.id === `tab-${target}`));
    };
  });

  // ===== Custom form =====
  function renderCustomForm(){
    const wrap = document.getElementById('customForm');
    if(!wrap) return;
    wrap.innerHTML='';
    for(const pat of PATTERNS){
      const conf = customMatrix[pat] || {enabled:false, items:[{},{},{},{}]};
      const items = conf.items || [{},{},{},{}];
      const block=document.createElement('div');
      block.className='card';
      const rows = [0,1,2,3].map(i=>{
        const it=items[i]||{};
        const name = String(it.name||'').replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/"/g,'&quot;');
        const bal = !!it.ballistic;
        return `
          <div class="row-inline">
            <div style="flex:1">
              <label>${i===0?'1 (Main)':' '+(i+1)}</label>
              <input data-p="${pat}" data-idx="${i}" placeholder="${i===0?'bijv. Military Press':'... (accessoire)'}" value="${name}">
            </div>
            <label class="chk" style="margin-top:22px"><input type="checkbox" data-p="${pat}" data-idx="${i}" data-bal ${bal?'checked':''}> Ballistic (x2)</label>
          </div>
        `;
      }).join('');
      block.innerHTML = `
        <div class="row" style="justify-content:space-between;align-items:center">
          <b>${pat}</b>
          <label class="chk"><input type="checkbox" data-p="${pat}" data-enable ${conf.enabled?'checked':''}> Override gebruiken</label>
        </div>
        ${rows}
      `;
      wrap.appendChild(block);
    }
  }
  function readCustomFromForm(){
    const obj={};
    document.querySelectorAll('input[data-enable]').forEach(chk=>{
      const p=chk.getAttribute('data-p');
      obj[p]=obj[p]||{enabled:false, items:[{},{},{},{}]};
      obj[p].enabled = chk.checked;
    });
    document.querySelectorAll('input[data-idx][type="text"]').forEach(inp=>{
      const p=inp.getAttribute('data-p'); const i=+inp.getAttribute('data-idx');
      obj[p]=obj[p]||{enabled:false, items:[{},{},{},{}]};
      obj[p].items[i]=obj[p].items[i]||{};
      obj[p].items[i].name = inp.value.trim();
    });
    document.querySelectorAll('input[data-bal]').forEach(chk=>{
      const p=chk.getAttribute('data-p'); const i=+chk.getAttribute('data-idx');
      obj[p]=obj[p]||{enabled:false, items:[{},{},{},{}]};
      obj[p].items[i]=obj[p].items[i]||{};
      obj[p].items[i].ballistic = chk.checked;
    });
    return obj;
  }

  renderCustomForm();

  const btnSaveCustom = document.getElementById('btnSaveCustom');
  if(btnSaveCustom){
    btnSaveCustom.onclick=()=>{
      customMatrix = readCustomFromForm();
      saveCustom(customMatrix);
      toast('Eigen oefeningen opgeslagen');
    };
  }
  const btnClearCustom = document.getElementById('btnClearCustom');
  if(btnClearCustom){
    btnClearCustom.onclick=()=>{
      customMatrix = {};
      saveCustom(customMatrix);
      renderCustomForm();
      toast('Eigen oefeningen geleegd');
    };
  }

  // ===== Buttons =====
  document.getElementById('btnNewBlock').onclick=newBlock;
  document.getElementById('btnRebuild').onclick=newBlock;
  document.getElementById('btnReset').onclick=resetProgress;
  document.getElementById('btnNextTop').onclick=()=>{ next(); };
  document.getElementById('btnPrevTop').onclick=()=>{ prev(); };
  document.getElementById('btnCompleteTop').onclick=complete;

  document.getElementById('selPS').addEventListener('change', (e)=>{
    const on = !!(e.target.value);
    document.getElementById('selPSVol').disabled = !on;
    const adv = document.getElementById('chkPSAdvanced'); if(adv) adv.disabled = !on;
  });

  const btnResetCounters = document.getElementById('btnResetCounters');
  if(btnResetCounters){
    btnResetCounters.onclick=()=>{ resetDayCounters(); renderSession(); toast('Tellers gereset voor deze sessie'); };
  }

  // ===== Boot =====
  if(state && state.plan){ renderInfo(); renderSession(); }
})();
</script>
</body>
</html>
